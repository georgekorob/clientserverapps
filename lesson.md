## Урок 6. Декораторы и продолжение работы с сетью
0:08 start web
0:14 deco_1
0:22 deco_2
0:26 deco_3
0:32 deco_4
0:37 deco_5
0:46 params_6
0:51 relax 1:01
1:02 two deco_7
1:03 class_8
1:06 class_9 init
1:08 decorate class_10
1:14 hw

## Задания 6
1. Продолжая задачу логирования, реализовать декоратор **@log**, фиксирующий обращение к декорируемой функции. Он сохраняет ее имя и аргументы.
2. В декораторе **@log** реализовать фиксацию функции, из которой была вызвана декорированная. Если имеется такой код:


    @log
    def func_z():
        pass
    def main():
        func_z()

...в логе должна быть отражена информация:

`"<дата-время> Функция func_z() вызвана из функции main"`

[//]: # (## Урок 5. Логирование)
[//]: # (* 0:17 start web)
[//]: # (* 0:20 hw)
[//]: # (* 0:26 description)
[//]: # (* 0:34 basic)
[//]: # (* 0:41 formatter 2)
[//]: # (* 0:49 formatter 3)
[//]: # (* 0:52 formatter 4)
[//]: # (* 0:57 formatter 5)
[//]: # (* 0:59 relax 1:09)
[//]: # (* 1:11 formatting 6)
[//]: # (* 1:12 config 7)
[//]: # (* 1:15 config 8)
[//]: # (* 1:17 hw)
[//]: # ()
[//]: # (## Задания 5)
[//]: # (Для проекта «Мессенджер» реализовать логирование с использованием модуля **logging**:)
[//]: # (1. В директории проекта создать каталог **log**, в котором для клиентской и серверной сторон в отдельных модулях формата **client_log_config.py** и **server_log_config.py** создать логгеры;)
[//]: # (2. В каждом модуле выполнить настройку соответствующего логгера по следующему алгоритму:)
[//]: # (   * a. Создание именованного логгера;)
[//]: # (   * b. Сообщения лога должны иметь следующий формат: **"<дата-время> <уровень_важности> <имя_модуля> <сообщение>"**;)
[//]: # (   * c. Журналирование должно производиться в лог-файл;)
[//]: # (   * d. На стороне сервера необходимо настроить ежедневную ротацию лог-файлов.)
[//]: # (3. Реализовать применение созданных логгеров для решения двух задач:)
[//]: # (   * a. Журналирование обработки исключений **try/except**. Вместо функции **print&#40;&#41;** использовать журналирование и обеспечить вывод служебных сообщений в лог-файл;)
[//]: # (   * b. Журналирование функций, исполняемых на серверной и клиентской сторонах при работе мессенджера.)
[//]: # ()
[//]: # (## Урок 4. Основы тестирования)
[//]: # (* 0:09 start web)
[//]: # (* 0:14 description)
[//]: # (* 0:25 assert)
[//]: # (* 0:29 salary)
[//]: # (* 0:38 decorator)
[//]: # (* 0:41 unittests)
[//]: # (* 0:45 sum)
[//]: # (* 0:48 python -m unittest ...)
[//]: # (* 0:49 pycharm config for tests)
[//]: # (* 0:51 salary)
[//]: # (* 0:54 assert table)
[//]: # (* 0:55 relax 1:06)
[//]: # (* 1:06 assert functions)
[//]: # (* 1:17 hw)
[//]: # ()
[//]: # (## Задания 4)
[//]: # (1. Для всех функций из урока 3 написать тесты с использованием unittest. Они должны быть оформлены в отдельных скриптах с префиксом test_ в имени файла &#40;например, test_client.py&#41;.)
[//]: # (2. *Написать тесты для домашних работ из курса «Python 1».)
[//]: # ()
[//]: # (## Урок 3. Основы сетевого программирования)
[//]: # (* 0:21 start web)
[//]: # (* 0:22 hw)
[//]: # (* 0:26 description sockets)
[//]: # (* 0:31 TCP)
[//]: # (* 0:34 table)
[//]: # (* 0:37 UDP)
[//]: # (* 0:39 time)
[//]: # (* 0:57 relax 1:08)
[//]: # (* 1:12 setsockopt)
[//]: # (* 1:13 data)
[//]: # (* 1:20 protocol JIM)
[//]: # (* 1:25 hw)
[//]: # ()
[//]: # (## Задания 3)
[//]: # (Реализовать простое клиент-серверное взаимодействие по протоколу JIM &#40;JSON instant messaging&#41;:)
[//]: # ()
[//]: # (* a. клиент отправляет запрос серверу;)
[//]: # (* b. сервер отвечает соответствующим кодом результата.)
[//]: # ()
[//]: # (Клиент и сервер должны быть реализованы в виде отдельных скриптов, содержащих соответствующие функции.)
[//]: # ()
[//]: # (**Функции клиента:**)
[//]: # (* сформировать presence-сообщение;)
[//]: # (* отправить сообщение серверу;)
[//]: # (* получить ответ сервера;)
[//]: # (* разобрать сообщение сервера;)
[//]: # (* параметры командной строки скрипта client.py \<addr> [\<port>]:)
[//]: # (  * addr — ip-адрес сервера;)
[//]: # (  * port — tcp-порт на сервере, по умолчанию 7777.)
[//]: # ()
[//]: # (**Функции сервера:**)
[//]: # (* принимает сообщение клиента;)
[//]: # (* формирует ответ клиенту;)
[//]: # (* отправляет ответ клиенту;)
[//]: # (* имеет параметры командной строки:)
[//]: # (  * -p \<port> — TCP-порт для работы &#40;по умолчанию использует 7777&#41;;)
[//]: # (  * -a \<addr> — IP-адрес для прослушивания &#40;по умолчанию слушает все доступные адреса&#41;.)
[//]: # ()
[//]: # (## Урок 2. Файловое хранение данных)
[//]: # (* 0:08 start web)
[//]: # (* 0:10 hw)
[//]: # (* 0:16 description csv)
[//]: # (* 0:44 json)
[//]: # (* 0:59 relax 1:09)
[//]: # (* 1:10 yaml)
[//]: # (* 1:16 hw)
[//]: # ()
[//]: # (## Задания 2)
[//]: # (1. Задание на закрепление знаний по модулю CSV. Написать скрипт, осуществляющий выборку определенных данных из файлов info_1.txt, info_2.txt, info_3.txt и формирующий новый «отчетный» файл в формате CSV. Для этого:)
[//]: # (* a. Создать функцию get_data&#40;&#41;, в которой в цикле осуществляется перебор файлов с данными, их открытие и считывание данных. В этой функции из считанных данных необходимо с помощью регулярных выражений извлечь значения параметров «Изготовитель системы», «Название ОС», «Код продукта», «Тип системы». Значения каждого параметра поместить в соответствующий список. Должно получиться четыре списка — например, os_prod_list, os_name_list, os_code_list, os_type_list. В этой же функции создать главный список для хранения данных отчета — например, main_data — и поместить в него названия столбцов отчета в виде списка: «Изготовитель системы», «Название ОС», «Код продукта», «Тип системы». Значения для этих столбцов также оформить в виде списка и поместить в файл main_data &#40;также для каждого файла&#41;;)
[//]: # (* b. Создать функцию write_to_csv&#40;&#41;, в которую передавать ссылку на CSV-файл. В этой функции реализовать получение данных через вызов функции get_data&#40;&#41;, а также сохранение подготовленных данных в соответствующий CSV-файл;)
[//]: # (* c. Проверить работу программы через вызов функции write_to_csv&#40;&#41;.)
[//]: # (2. Задание на закрепление знаний по модулю json. Есть файл orders в формате JSON с информацией о заказах. Написать скрипт, автоматизирующий его заполнение данными. Для этого:)
[//]: # (* a. Создать функцию write_order_to_json&#40;&#41;, в которую передается 5 параметров — товар &#40;item&#41;, количество &#40;quantity&#41;, цена &#40;price&#41;, покупатель &#40;buyer&#41;, дата &#40;date&#41;. Функция должна предусматривать запись данных в виде словаря в файл orders.json. При записи данных указать величину отступа в 4 пробельных символа;)
[//]: # (* b. Проверить работу программы через вызов функции write_order_to_json&#40;&#41; с передачей в нее значений каждого параметра.)
[//]: # (3. Задание на закрепление знаний по модулю yaml. Написать скрипт, автоматизирующий сохранение данных в файле YAML-формата. Для этого:)
[//]: # (* a. Подготовить данные для записи в виде словаря, в котором первому ключу соответствует список, второму — целое число, третьему — вложенный словарь, где значение каждого ключа — это целое число с юникод-символом, отсутствующим в кодировке ASCII &#40;например, €&#41;;)
[//]: # (* b. Реализовать сохранение данных в файл формата YAML — например, в файл file.yaml. При этом обеспечить стилизацию файла с помощью параметра default_flow_style, а также установить возможность работы с юникодом: allow_unicode = True;)
[//]: # (* c. Реализовать считывание данных из созданного файла и проверить, совпадают ли они с исходными.)
[//]: # ()
[//]: # (## Урок 1. Концепции хранения информации)
[//]: # (* 0:13 start web)
[//]: # (* 0:30 start lesson)
[//]: # (* 0:42 ascii)
[//]: # (* 0:44 unicode)
[//]: # (* 0:47 strings)
[//]: # (* 0:52 bytes)
[//]: # (* 0:55 utf-8)
[//]: # (* 0:58 encode | decode)
[//]: # (* 1:00 relax 1:10)
[//]: # (* 1:12 modules | subprocess | chardet)
[//]: # (* 1:16 errors)
[//]: # (* 1:17 error handling)
[//]: # (* 1:21 files)
[//]: # (* 1:30 hw)
[//]: # ()
[//]: # (## Задания 1)
[//]: # (1. Каждое из слов «разработка», «сокет», «декоратор» представить в строковом формате и проверить тип и содержание соответствующих переменных. Затем с помощью онлайн-конвертера преобразовать строковые представление в формат Unicode и также проверить тип и содержимое переменных.)
[//]: # (2. Каждое из слов «class», «function», «method» записать в байтовом типе без преобразования в последовательность кодов &#40;не используя методы encode и decode&#41; и определить тип, содержимое и длину соответствующих переменных.)
[//]: # (3. Определить, какие из слов «attribute», «класс», «функция», «type» невозможно записать в байтовом типе.)
[//]: # (4. Преобразовать слова «разработка», «администрирование», «protocol», «standard» из строкового представления в байтовое и выполнить обратное преобразование &#40;используя методы encode и decode&#41;.)
[//]: # (5. Выполнить пинг веб-ресурсов yandex.ru, youtube.com и преобразовать результаты из байтовового в строковый тип на кириллице.)
[//]: # (6. Создать текстовый файл test_file.txt, заполнить его тремя строками: «сетевое программирование», «сокет», «декоратор». Проверить кодировку файла по умолчанию. Принудительно открыть файл в формате Unicode и вывести его содержимое.)
