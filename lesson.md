## Урок 3. Основы сетевого программирования
* 0:21 start web
* 0:22 hw
* 0:26 description sockets
* 0:31 TCP
* 0:34 table
* 0:37 UDP
* 0:39 time
* 0:57 relax 1:08
* 1:12 setsockopt
* 1:13 data
* 1:20 protocol JIM
* 1:25 hw

## Задания 3
Реализовать простое клиент-серверное взаимодействие по протоколу JIM (JSON instant messaging):

* a. клиент отправляет запрос серверу;
* b. сервер отвечает соответствующим кодом результата.

Клиент и сервер должны быть реализованы в виде отдельных скриптов, содержащих соответствующие функции.

**Функции клиента:**
* сформировать presence-сообщение;
* отправить сообщение серверу;
* получить ответ сервера;
* разобрать сообщение сервера;
* параметры командной строки скрипта client.py \<addr> [\<port>]:
  * addr — ip-адрес сервера;
  * port — tcp-порт на сервере, по умолчанию 7777.

**Функции сервера:**
* принимает сообщение клиента;
* формирует ответ клиенту;
* отправляет ответ клиенту;
* имеет параметры командной строки:
  * -p \<port> — TCP-порт для работы (по умолчанию использует 7777);
  * -a \<addr> — IP-адрес для прослушивания (по умолчанию слушает все доступные адреса).

[//]: # (## Урок 2. Файловое хранение данных)
[//]: # (* 0:08 start web)
[//]: # (* 0:10 hw)
[//]: # (* 0:16 description csv)
[//]: # (* 0:44 json)
[//]: # (* 0:59 relax 1:09)
[//]: # (* 1:10 yaml)
[//]: # (* 1:16 hw)
[//]: # (## Задания 2)
[//]: # (1. Задание на закрепление знаний по модулю CSV. Написать скрипт, осуществляющий выборку определенных данных из файлов info_1.txt, info_2.txt, info_3.txt и формирующий новый «отчетный» файл в формате CSV. Для этого:)
[//]: # (* a. Создать функцию get_data&#40;&#41;, в которой в цикле осуществляется перебор файлов с данными, их открытие и считывание данных. В этой функции из считанных данных необходимо с помощью регулярных выражений извлечь значения параметров «Изготовитель системы», «Название ОС», «Код продукта», «Тип системы». Значения каждого параметра поместить в соответствующий список. Должно получиться четыре списка — например, os_prod_list, os_name_list, os_code_list, os_type_list. В этой же функции создать главный список для хранения данных отчета — например, main_data — и поместить в него названия столбцов отчета в виде списка: «Изготовитель системы», «Название ОС», «Код продукта», «Тип системы». Значения для этих столбцов также оформить в виде списка и поместить в файл main_data &#40;также для каждого файла&#41;;)
[//]: # (* b. Создать функцию write_to_csv&#40;&#41;, в которую передавать ссылку на CSV-файл. В этой функции реализовать получение данных через вызов функции get_data&#40;&#41;, а также сохранение подготовленных данных в соответствующий CSV-файл;)
[//]: # (* c. Проверить работу программы через вызов функции write_to_csv&#40;&#41;.)
[//]: # (2. Задание на закрепление знаний по модулю json. Есть файл orders в формате JSON с информацией о заказах. Написать скрипт, автоматизирующий его заполнение данными. Для этого:)
[//]: # (* a. Создать функцию write_order_to_json&#40;&#41;, в которую передается 5 параметров — товар &#40;item&#41;, количество &#40;quantity&#41;, цена &#40;price&#41;, покупатель &#40;buyer&#41;, дата &#40;date&#41;. Функция должна предусматривать запись данных в виде словаря в файл orders.json. При записи данных указать величину отступа в 4 пробельных символа;)
[//]: # (* b. Проверить работу программы через вызов функции write_order_to_json&#40;&#41; с передачей в нее значений каждого параметра.)
[//]: # (3. Задание на закрепление знаний по модулю yaml. Написать скрипт, автоматизирующий сохранение данных в файле YAML-формата. Для этого:)
[//]: # (* a. Подготовить данные для записи в виде словаря, в котором первому ключу соответствует список, второму — целое число, третьему — вложенный словарь, где значение каждого ключа — это целое число с юникод-символом, отсутствующим в кодировке ASCII &#40;например, €&#41;;)
[//]: # (* b. Реализовать сохранение данных в файл формата YAML — например, в файл file.yaml. При этом обеспечить стилизацию файла с помощью параметра default_flow_style, а также установить возможность работы с юникодом: allow_unicode = True;)
[//]: # (* c. Реализовать считывание данных из созданного файла и проверить, совпадают ли они с исходными.)
[//]: # (## Урок 1. Концепции хранения информации)
[//]: # (* 0:13 start web)
[//]: # (* 0:30 start lesson)
[//]: # (* 0:42 ascii)
[//]: # (* 0:44 unicode)
[//]: # (* 0:47 strings)
[//]: # (* 0:52 bytes)
[//]: # (* 0:55 utf-8)
[//]: # (* 0:58 encode | decode)
[//]: # (* 1:00 relax 1:10)
[//]: # (* 1:12 modules | subprocess | chardet)
[//]: # (* 1:16 errors)
[//]: # (* 1:17 error handling)
[//]: # (* 1:21 files)
[//]: # (* 1:30 hw)
[//]: # (## Задания 1)
[//]: # (1. Каждое из слов «разработка», «сокет», «декоратор» представить в строковом формате и проверить тип и содержание соответствующих переменных. Затем с помощью онлайн-конвертера преобразовать строковые представление в формат Unicode и также проверить тип и содержимое переменных.)
[//]: # (2. Каждое из слов «class», «function», «method» записать в байтовом типе без преобразования в последовательность кодов &#40;не используя методы encode и decode&#41; и определить тип, содержимое и длину соответствующих переменных.)
[//]: # (3. Определить, какие из слов «attribute», «класс», «функция», «type» невозможно записать в байтовом типе.)
[//]: # (4. Преобразовать слова «разработка», «администрирование», «protocol», «standard» из строкового представления в байтовое и выполнить обратное преобразование &#40;используя методы encode и decode&#41;.)
[//]: # (5. Выполнить пинг веб-ресурсов yandex.ru, youtube.com и преобразовать результаты из байтовового в строковый тип на кириллице.)
[//]: # (6. Создать текстовый файл test_file.txt, заполнить его тремя строками: «сетевое программирование», «сокет», «декоратор». Проверить кодировку файла по умолчанию. Принудительно открыть файл в формате Unicode и вывести его содержимое.)
