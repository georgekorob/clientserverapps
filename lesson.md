## Урок pyqt 8. Подготовка дистрибутива
* 0:10 startweb
* 0:15 __file__ getcwd sys.exit
* 0:25 pypi whl
* 0:43 relax 0:53
* 1:00 hw build_exe

## Задания pyqt 8
1. Для разработанного проекта «Мессенджер» сформировать whl-пакеты с дистрибутивами сервера и клиента.
2. *Выполнить процедуру сборки созданного проекта «Мессенджер» с помощью утилиты **cx_Freeze**.
3. Выполнить загрузку сформированных whl-пакетов с дистрибутивами сервера и клиента в репозиторий сервиса PyPi.
4. В качестве защиты курсового проекта необходимо записать в любой удобной для вас программе видеоролик (скринкаст) продолжительностью 1-5 минут. Представьте, что вам необходимо презентовать вашу работу заказчику или аудитории. В скринкасте расскажите о вашем проекте, продемонстрируйте его возможности и функционал. Ссылку на видео приложите к практическому заданию, например, в комментарии к уроку. И не забудьте открыть доступ на просмотр! :) Видеопрезентация продукта развивает у вас дополнительные мягкие навыки и является обязательной для засчитывания курсового проекта. 

[comment]: <> ()
[comment]: <> (## Урок pyqt 7. PEP-8, подготовка документации)
[comment]: <> (* 0:04 startweb)
[comment]: <> (* 0:14 code style)
[comment]: <> (* 0:15 pylint)
[comment]: <> (* 0:28 ex_2)
[comment]: <> (* 0:34 ex_3)
[comment]: <> (* 0:36 ex_4)
[comment]: <> (* 0:38 ex_5)
[comment]: <> (* 0:40 random name)
[comment]: <> (* 0:44 relax 0:55)
[comment]: <> (* 0:56 sphinx)
[comment]: <> (* 1:07 hw)
[comment]: <> ()
[comment]: <> (## Задания pyqt 7)
[comment]: <> (1. Для проекта «Мессенджер» подготовить документацию с использованием sphinx-doc.)
[comment]: <> (2. Проверить программный код практических заданий текущего курса и курса Python-1 на соответствие положениям PEP-8. При необходимости выполнить преобразования.)
[comment]: <> ()
[comment]: <> (## Урок pyqt 6. Безопасность)
[comment]: <> (* 0:02 startweb)
[comment]: <> (* 0:21 ex_1 hashlib pbkdf2_hmac)
[comment]: <> (* 0:27 ex_2 authenticate hmac)
[comment]: <> (* 0:43 ex_3 pycryptodome cipher)
[comment]: <> (* 0:56 relax 1:03)
[comment]: <> (* 1:04 ex_4 sql_injection)
[comment]: <> (* 1:13 ex_5 pickle bandit)
[comment]: <> (* 1:21 hw)
[comment]: <> ()
[comment]: <> (## Задания pyqt 6)
[comment]: <> (1. Реализовать аутентификацию пользователей на сервере.)
[comment]: <> (2. Реализовать декоратор **@login_required**, проверяющий авторизованность пользователя для выполнения той или иной функции.)
[comment]: <> (3. Реализовать хранение паролей в БД сервера &#40;пароли не хранятся в открытом виде — хранится хэш-образ от пароля с добавлением криптографической соли&#41;.)
[comment]: <> (4. *Реализовать возможность сквозного шифрования сообщений &#40;использовать асимметричный шифр, ключи которого хранятся только у клиентов&#41;.)
[comment]: <> ()
[comment]: <> (## Урок pyqt 5. Qt &#40;продолжение&#41;, Qt и потоки)
[comment]: <> (* 0:08 startweb)
[comment]: <> (* 0:38 description)
[comment]: <> (* 0:41 ex_1 pyqtSignal)
[comment]: <> (* 0:51 relax 1:01)
[comment]: <> (* 1:01 ex_2 connect)
[comment]: <> (* 1:06 ex_3 make_connection)
[comment]: <> (* 1:19 ex_4 QEvent)
[comment]: <> (* 1:24 ex_5 database)
[comment]: <> (* 1:26 sklad tables)
[comment]: <> (* 1:34 ex_6 finder QThread)
[comment]: <> (* 1:44 hw)
[comment]: <> ()
[comment]: <> (## Задания pyqt 5)
[comment]: <> (Продолжаем работать над мессенджером:)
[comment]: <> (1. Реализовать графический интерфейс пользователя на стороне клиента:)
[comment]: <> (- Отображение списка контактов;)
[comment]: <> (- Выбор чата двойным кликом на элементе списка контактов;)
[comment]: <> (- Добавление нового контакта в локальный список контактов;)
[comment]: <> (- Отображение сообщений в окне чата;)
[comment]: <> (- Набор сообщения в окне ввода сообщения;)
[comment]: <> (- Отправка введенного сообщения.)
[comment]: <> ()
[comment]: <> (## Урок pyqt 4. Хранение данных в БД &#40;продолжение&#41; и основы Qt)
[comment]: <> (* 0:09 startweb)
[comment]: <> (* 0:16 hw -1)
[comment]: <> (* 0:23 ex_1 ui widget)
[comment]: <> (* 0:36 ex_2 pyuic5)
[comment]: <> (* 0:49 relax 0:59)
[comment]: <> (* 1:00 ex_3 resize move)
[comment]: <> (* 1:03 ex_4 QAction)
[comment]: <> (* 1:11 create)
[comment]: <> (* 1:13 hw)
[comment]: <> ()
[comment]: <> (## Задания pyqt 4)
[comment]: <> (1. Продолжить реализацию класса хранилища для серверной стороны.)
[comment]: <> (- a. Реализовать функционал работы со списком контактов по протоколу **JIM**:<br>)
[comment]: <> (  **Получение списка контактов**<br>)
[comment]: <> (  Запрос к серверу:)
[comment]: <> (```markdown)
[comment]: <> ({)
[comment]: <> (  "action": "get_contacts",)
[comment]: <> (  "time": <unix timestamp>,)
[comment]: <> (  "user_login": "login")
[comment]: <> (})
[comment]: <> (```)
[comment]: <> (Положительный ответ сервера будет содержать список контактов:)
[comment]: <> (```markdown)
[comment]: <> ({)
[comment]: <> (  "response": "202",)
[comment]: <> (  "alert": "[‘nick_1’, ‘nick_2’,...]")
[comment]: <> (})
[comment]: <> (```)
[comment]: <> (Получение списка контактов — не самая частая операция при взаимодействии с сервером. Она должна выполняться после подключения и авторизации клиента. Инициируется им же. В процессе получения списка контактов клиент не должен инициировать другие запросы.<br>)
[comment]: <> (**Добавление/удаление контакта** в список контактов:<br>)
[comment]: <> (Запрос к серверу:)
[comment]: <> (```markdown)
[comment]: <> ({)
[comment]: <> (  "action": "add_contact" | "del_contact",)
[comment]: <> (  "user_id": "nickname",)
[comment]: <> (  "time": <unix timestamp>,)
[comment]: <> (  "user_login": "login")
[comment]: <> (})
[comment]: <> (```)
[comment]: <> (Ответ сервера будет содержать одно сообщение с кодом результата и необязательной расшифровкой:)
[comment]: <> (```markdown)
[comment]: <> ({)
[comment]: <> (  "response": xxx,)
[comment]: <> (})
[comment]: <> (```)
[comment]: <> (- b. Реализовать хранение информации в БД на стороне клиента:<br>)
[comment]: <> (список_контактов;<br>)
[comment]: <> (история_сообщений.)
[comment]: <> (2. Реализовать графический интерфейс для мессенджера, используя библиотеку PyQt. Реализовать графический интерфейс администратора сервера:)
[comment]: <> (- a. отображение списка всех клиентов;)
[comment]: <> (- b. отображение статистики клиентов;)
[comment]: <> (- c. настройка сервера &#40;подключение к БД, идентификация&#41;.)
[comment]: <> ()
[comment]: <> (## Урок pyqt 3. Хранение данных в БД. ORM SQLAlchemy)
[comment]: <> (* 0:10 startweb)
[comment]: <> (* 0:22 description)
[comment]: <> (* 0:37 exp_1 commit)
[comment]: <> (* 0:42 exp_2 executescript)
[comment]: <> (* 0:50 exp_3 parameters ?)
[comment]: <> (* 0:56 exp_4 for)
[comment]: <> (* 0:57 exp_5 error)
[comment]: <> (* 1:03 relax 1:14)
[comment]: <> (* 1:02 exp_6 SQLAlchemy mapper session)
[comment]: <> (* 1:23 exp_7 declarative_base)
[comment]: <> (* 1:26 hw)
[comment]: <> ()
[comment]: <> (## Задания pyqt 3)
[comment]: <> (1. Начать реализацию класса «**Хранилище**» для серверной стороны. Хранение необходимо осуществлять в базе данных. В качестве СУБД использовать **sqlite**. Для взаимодействия с БД можно применять ORM.)
[comment]: <> (Опорная схема базы данных на стороне сервера БД содержит следующие таблицы:)
[comment]: <> (* клиент:)
[comment]: <> (  * логин;)
[comment]: <> (  * информация.)
[comment]: <> (* история_клиента:)
[comment]: <> (  * время входа;)
[comment]: <> (  * ip-адрес.)
[comment]: <> (* список_контактов &#40;составляется на основании выборки всех записей с id_владельца&#41;:)
[comment]: <> (  * id_владельца;)
[comment]: <> (  * id_клиента.)
[comment]: <> ()
[comment]: <> (## Урок pyqt 2. Дескрипторы и метаклассы)
[comment]: <> (* 0:10 start web)
[comment]: <> (* 0:19 descriptors)
[comment]: <> (* 0:20 simple)
[comment]: <> (* 0:23 if)
[comment]: <> (* 0:26 property setter)
[comment]: <> (* 0:32 descriptor class)
[comment]: <> (* 0:40 __set_name__)
[comment]: <> (* 0:46 relax 0:56)
[comment]: <> (* 0:57 metaclasses)
[comment]: <> (* 1:00 AttrOptim class)
[comment]: <> (* 1:05 prepare new init call)
[comment]: <> (* 1:11 example doctype init)
[comment]: <> (* 1:16 hw)
[comment]: <> ()
[comment]: <> (## Задания pyqt 2)
[comment]: <> (Продолжение работы с проектом «Мессенджер»:)
[comment]: <> (1. Реализовать метакласс **ClientVerifier**, выполняющий базовую проверку класса «Клиент» &#40;для некоторых проверок уместно использовать модуль **dis**&#41;:)
[comment]: <> (   * отсутствие вызовов **accept** и **listen** для сокетов;)
[comment]: <> (   * использование сокетов для работы по **TCP**;)
[comment]: <> (   * отсутствие создания сокетов на уровне классов, то есть отсутствие конструкций такого вида:)
[comment]: <> (```python)
[comment]: <> (class Client:)
[comment]: <> (    s = socket&#40;&#41;)
[comment]: <> (    ...)
[comment]: <> (```)
[comment]: <> (2. Реализовать метакласс **ServerVerifier**, выполняющий базовую проверку класса «Сервер»:)
[comment]: <> (   * отсутствие вызовов **connect** для сокетов;)
[comment]: <> (   * использование сокетов для работы по **TCP**.)
[comment]: <> (3. Реализовать дескриптор для класса серверного сокета, а в нем — проверку номера порта. Это должно быть целое число &#40;>=0&#41;. Значение порта по умолчанию равняется 7777. Дескриптор надо создать в отдельном классе. Его экземпляр добавить в пределах класса серверного сокета. Номер порта передается в экземпляр дескриптора при запуске сервера.)
[comment]: <> ()
[comment]: <> (## Урок pyqt 1. Полезные модули)
[comment]: <> (* 0:10 start web)
[comment]: <> (* 0:19 server)
[comment]: <> (* 0:34 client)
[comment]: <> (* 0:44 description | subrocess)
[comment]: <> (* 1:02 relax 1:12 | ipaddress)
[comment]: <> (* 1:21 os)
[comment]: <> (* 1:25 tabulate)
[comment]: <> (* 1:29 pprint)
[comment]: <> (* 1:31 hw)
[comment]: <> ()
[comment]: <> (## Задания pyqt 1)
[comment]: <> (1. Написать функцию **host_ping&#40;&#41;**, в которой с помощью утилиты **ping** будет проверяться доступность сетевых узлов. Аргументом функции является список, в котором каждый сетевой узел должен быть представлен именем хоста или ip-адресом. В функции необходимо перебирать ip-адреса и проверять их доступность с выводом соответствующего сообщения &#40;«Узел доступен», «Узел недоступен»&#41;. При этом ip-адрес сетевого узла должен создаваться с помощью функции **ip_address&#40;&#41;**.)
[comment]: <> (2. Написать функцию **host_range_ping&#40;&#41;** для перебора ip-адресов из заданного диапазона. Меняться должен только последний октет каждого адреса. По результатам проверки должно выводиться соответствующее сообщение.)
[comment]: <> (3. Написать функцию **host_range_ping_tab&#40;&#41;**, возможности которой основаны на функции из примера 2. Но в данном случае результат должен быть итоговым по всем ip-адресам, представленным в табличном формате &#40;использовать модуль **tabulate**&#41;. Таблица должна состоять из двух колонок и выглядеть примерно так:)
[comment]: <> (Reachable | Unreachable)
[comment]: <> (--- | ---)
[comment]: <> (10.0.0.1 | 10.0.0.3)
[comment]: <> (10.0.0.2 | 10.0.0.4)
[comment]: <> ()
[comment]: <> (## Урок 8. Потоки)
[comment]: <> (* 0:15 start web)
[comment]: <> (* 0:23 simple_1 thread)
[comment]: <> (* 0:34 simple_2 class)
[comment]: <> (* 0:39 simple_3 class many)
[comment]: <> (* 0:41 test_1 log)
[comment]: <> (* 0:47 thread multiproc)
[comment]: <> (* 0:56 processing_9)
[comment]: <> (* 1:00 relax 1:10)
[comment]: <> (* 1:12 thread_5 Lock acquire release)
[comment]: <> (* 1:17 hw)
[comment]: <> ()
[comment]: <> (## Задания 8)
[comment]: <> (1. На клиентской стороне реализовать прием и отправку сообщений с помощью потоков в P2P-формате &#40;обмен сообщениями между двумя пользователями&#41;.)
[comment]: <> (Итогом выполнения практических заданий первой части продвинутого курса Python стал консольный мессенджер. Усовершенствуем его во второй части: реализуем взаимосвязь мессенджера с базами данных и создадим для него графический пользовательский интерфейс.)
[comment]: <> ()
[comment]: <> (## Урок 7. Модуль select, слоты)
[comment]: <> (* 0:09 start web)
[comment]: <> (* 0:12 description)
[comment]: <> (* 0:18 select)
[comment]: <> (* 0:22 server select)
[comment]: <> (* 0:37 echo server)
[comment]: <> (* 0:51 relax 1:01)
[comment]: <> (* 1:02 slots)
[comment]: <> (* 1:07 hw)
[comment]: <> ()
[comment]: <> (## Задания 7)
[comment]: <> (Продолжаем работу над проектом «Мессенджер»:)
[comment]: <> (1. Реализовать обработку нескольких клиентов на сервере, используя функцию **select**. Клиенты должны общаться в «общем чате»: каждое сообщение участника отправляется всем, подключенным к серверу.)
[comment]: <> (2. Реализовать функции отправки/приема данных на стороне клиента. Чтобы упростить разработку на данном этапе, пусть клиентское приложение будет либо только принимать, либо только отправлять сообщения в общий чат. Эти функции надо реализовать в рамках отдельных скриптов.)
[comment]: <> ()
[comment]: <> (## Урок 6. Декораторы и продолжение работы с сетью)
[comment]: <> (* 0:08 start web)
[comment]: <> (* 0:14 deco_1)
[comment]: <> (* 0:22 deco_2)
[comment]: <> (* 0:26 deco_3)
[comment]: <> (* 0:32 deco_4)
[comment]: <> (* 0:37 deco_5)
[comment]: <> (* 0:46 params_6)
[comment]: <> (* 0:51 relax 1:01)
[comment]: <> (* 1:02 two deco_7)
[comment]: <> (* 1:03 class_8)
[comment]: <> (* 1:06 class_9 init)
[comment]: <> (* 1:08 decorate class_10)
[comment]: <> (* 1:14 hw)
[comment]: <> ()
[comment]: <> (## Задания 6)
[comment]: <> (1. Продолжая задачу логирования, реализовать декоратор **@log**, фиксирующий обращение к декорируемой функции. Он сохраняет ее имя и аргументы.)
[comment]: <> (2. В декораторе **@log** реализовать фиксацию функции, из которой была вызвана декорированная. Если имеется такой код:)
[comment]: <> ()
[comment]: <> ()
[comment]: <> (    @log)
[comment]: <> (    def func_z&#40;&#41;:)
[comment]: <> (        pass)
[comment]: <> (    def main&#40;&#41;:)
[comment]: <> (        func_z&#40;&#41;)
[comment]: <> ()
[comment]: <> (...в логе должна быть отражена информация:)
[comment]: <> ()
[comment]: <> (`"<дата-время> Функция func_z&#40;&#41; вызвана из функции main"`)
[comment]: <> ()
[comment]: <> (## Урок 5. Логирование)
[comment]: <> (* 0:17 start web)
[comment]: <> (* 0:20 hw)
[comment]: <> (* 0:26 description)
[comment]: <> (* 0:34 basic)
[comment]: <> (* 0:41 formatter 2)
[comment]: <> (* 0:49 formatter 3)
[comment]: <> (* 0:52 formatter 4)
[comment]: <> (* 0:57 formatter 5)
[comment]: <> (* 0:59 relax 1:09)
[comment]: <> (* 1:11 formatting 6)
[comment]: <> (* 1:12 config 7)
[comment]: <> (* 1:15 config 8)
[comment]: <> (* 1:17 hw)
[comment]: <> ()
[comment]: <> (## Задания 5)
[comment]: <> (Для проекта «Мессенджер» реализовать логирование с использованием модуля **logging**:)
[comment]: <> (1. В директории проекта создать каталог **log**, в котором для клиентской и серверной сторон в отдельных модулях формата **client_log_config.py** и **server_log_config.py** создать логгеры;)
[comment]: <> (2. В каждом модуле выполнить настройку соответствующего логгера по следующему алгоритму:)
[comment]: <> (   * a. Создание именованного логгера;)
[comment]: <> (   * b. Сообщения лога должны иметь следующий формат: **"<дата-время> <уровень_важности> <имя_модуля> <сообщение>"**;)
[comment]: <> (   * c. Журналирование должно производиться в лог-файл;)
[comment]: <> (   * d. На стороне сервера необходимо настроить ежедневную ротацию лог-файлов.)
[comment]: <> (3. Реализовать применение созданных логгеров для решения двух задач:)
[comment]: <> (   * a. Журналирование обработки исключений **try/except**. Вместо функции **print&#40;&#41;** использовать журналирование и обеспечить вывод служебных сообщений в лог-файл;)
[comment]: <> (   * b. Журналирование функций, исполняемых на серверной и клиентской сторонах при работе мессенджера.)
[comment]: <> ()
[comment]: <> (## Урок 4. Основы тестирования)
[comment]: <> (* 0:09 start web)
[comment]: <> (* 0:14 description)
[comment]: <> (* 0:25 assert)
[comment]: <> (* 0:29 salary)
[comment]: <> (* 0:38 decorator)
[comment]: <> (* 0:41 unittests)
[comment]: <> (* 0:45 sum)
[comment]: <> (* 0:48 python -m unittest ...)
[comment]: <> (* 0:49 pycharm config for tests)
[comment]: <> (* 0:51 salary)
[comment]: <> (* 0:54 assert table)
[comment]: <> (* 0:55 relax 1:06)
[comment]: <> (* 1:06 assert functions)
[comment]: <> (* 1:17 hw)
[comment]: <> ()
[comment]: <> (## Задания 4)
[comment]: <> (1. Для всех функций из урока 3 написать тесты с использованием unittest. Они должны быть оформлены в отдельных скриптах с префиксом test_ в имени файла &#40;например, test_client.py&#41;.)
[comment]: <> (2. *Написать тесты для домашних работ из курса «Python 1».)
[comment]: <> ()
[comment]: <> (## Урок 3. Основы сетевого программирования)
[comment]: <> (* 0:21 start web)
[comment]: <> (* 0:22 hw)
[comment]: <> (* 0:26 description sockets)
[comment]: <> (* 0:31 TCP)
[comment]: <> (* 0:34 table)
[comment]: <> (* 0:37 UDP)
[comment]: <> (* 0:39 time)
[comment]: <> (* 0:57 relax 1:08)
[comment]: <> (* 1:12 setsockopt)
[comment]: <> (* 1:13 data)
[comment]: <> (* 1:20 protocol JIM)
[comment]: <> (* 1:25 hw)
[comment]: <> ()
[comment]: <> (## Задания 3)
[comment]: <> (Реализовать простое клиент-серверное взаимодействие по протоколу JIM &#40;JSON instant messaging&#41;:)
[comment]: <> ()
[comment]: <> (* a. клиент отправляет запрос серверу;)
[comment]: <> (* b. сервер отвечает соответствующим кодом результата.)
[comment]: <> ()
[comment]: <> (Клиент и сервер должны быть реализованы в виде отдельных скриптов, содержащих соответствующие функции.)
[comment]: <> ()
[comment]: <> (**Функции клиента:**)
[comment]: <> (* сформировать presence-сообщение;)
[comment]: <> (* отправить сообщение серверу;)
[comment]: <> (* получить ответ сервера;)
[comment]: <> (* разобрать сообщение сервера;)
[comment]: <> (* параметры командной строки скрипта client.py \<addr> [\<port>]:)
[comment]: <> (  * addr — ip-адрес сервера;)
[comment]: <> (  * port — tcp-порт на сервере, по умолчанию 7777.)
[comment]: <> ()
[comment]: <> (**Функции сервера:**)
[comment]: <> (* принимает сообщение клиента;)
[comment]: <> (* формирует ответ клиенту;)
[comment]: <> (* отправляет ответ клиенту;)
[comment]: <> (* имеет параметры командной строки:)
[comment]: <> (  * -p \<port> — TCP-порт для работы &#40;по умолчанию использует 7777&#41;;)
[comment]: <> (  * -a \<addr> — IP-адрес для прослушивания &#40;по умолчанию слушает все доступные адреса&#41;.)
[comment]: <> ()
[comment]: <> (## Урок 2. Файловое хранение данных)
[comment]: <> (* 0:08 start web)
[comment]: <> (* 0:10 hw)
[comment]: <> (* 0:16 description csv)
[comment]: <> (* 0:44 json)
[comment]: <> (* 0:59 relax 1:09)
[comment]: <> (* 1:10 yaml)
[comment]: <> (* 1:16 hw)
[comment]: <> ()
[comment]: <> (## Задания 2)
[comment]: <> (1. Задание на закрепление знаний по модулю CSV. Написать скрипт, осуществляющий выборку определенных данных из файлов info_1.txt, info_2.txt, info_3.txt и формирующий новый «отчетный» файл в формате CSV. Для этого:)
[comment]: <> (* a. Создать функцию get_data&#40;&#41;, в которой в цикле осуществляется перебор файлов с данными, их открытие и считывание данных. В этой функции из считанных данных необходимо с помощью регулярных выражений извлечь значения параметров «Изготовитель системы», «Название ОС», «Код продукта», «Тип системы». Значения каждого параметра поместить в соответствующий список. Должно получиться четыре списка — например, os_prod_list, os_name_list, os_code_list, os_type_list. В этой же функции создать главный список для хранения данных отчета — например, main_data — и поместить в него названия столбцов отчета в виде списка: «Изготовитель системы», «Название ОС», «Код продукта», «Тип системы». Значения для этих столбцов также оформить в виде списка и поместить в файл main_data &#40;также для каждого файла&#41;;)
[comment]: <> (* b. Создать функцию write_to_csv&#40;&#41;, в которую передавать ссылку на CSV-файл. В этой функции реализовать получение данных через вызов функции get_data&#40;&#41;, а также сохранение подготовленных данных в соответствующий CSV-файл;)
[comment]: <> (* c. Проверить работу программы через вызов функции write_to_csv&#40;&#41;.)
[comment]: <> (2. Задание на закрепление знаний по модулю json. Есть файл orders в формате JSON с информацией о заказах. Написать скрипт, автоматизирующий его заполнение данными. Для этого:)
[comment]: <> (* a. Создать функцию write_order_to_json&#40;&#41;, в которую передается 5 параметров — товар &#40;item&#41;, количество &#40;quantity&#41;, цена &#40;price&#41;, покупатель &#40;buyer&#41;, дата &#40;date&#41;. Функция должна предусматривать запись данных в виде словаря в файл orders.json. При записи данных указать величину отступа в 4 пробельных символа;)
[comment]: <> (* b. Проверить работу программы через вызов функции write_order_to_json&#40;&#41; с передачей в нее значений каждого параметра.)
[comment]: <> (3. Задание на закрепление знаний по модулю yaml. Написать скрипт, автоматизирующий сохранение данных в файле YAML-формата. Для этого:)
[comment]: <> (* a. Подготовить данные для записи в виде словаря, в котором первому ключу соответствует список, второму — целое число, третьему — вложенный словарь, где значение каждого ключа — это целое число с юникод-символом, отсутствующим в кодировке ASCII &#40;например, €&#41;;)
[comment]: <> (* b. Реализовать сохранение данных в файл формата YAML — например, в файл file.yaml. При этом обеспечить стилизацию файла с помощью параметра default_flow_style, а также установить возможность работы с юникодом: allow_unicode = True;)
[comment]: <> (* c. Реализовать считывание данных из созданного файла и проверить, совпадают ли они с исходными.)
[comment]: <> ()
[comment]: <> (## Урок 1. Концепции хранения информации)
[comment]: <> (* 0:13 start web)
[comment]: <> (* 0:30 start lesson)
[comment]: <> (* 0:42 ascii)
[comment]: <> (* 0:44 unicode)
[comment]: <> (* 0:47 strings)
[comment]: <> (* 0:52 bytes)
[comment]: <> (* 0:55 utf-8)
[comment]: <> (* 0:58 encode | decode)
[comment]: <> (* 1:00 relax 1:10)
[comment]: <> (* 1:12 modules | subprocess | chardet)
[comment]: <> (* 1:16 errors)
[comment]: <> (* 1:17 error handling)
[comment]: <> (* 1:21 files)
[comment]: <> (* 1:30 hw)
[comment]: <> ()
[comment]: <> (## Задания 1)
[comment]: <> (1. Каждое из слов «разработка», «сокет», «декоратор» представить в строковом формате и проверить тип и содержание соответствующих переменных. Затем с помощью онлайн-конвертера преобразовать строковые представление в формат Unicode и также проверить тип и содержимое переменных.)
[comment]: <> (2. Каждое из слов «class», «function», «method» записать в байтовом типе без преобразования в последовательность кодов &#40;не используя методы encode и decode&#41; и определить тип, содержимое и длину соответствующих переменных.)
[comment]: <> (3. Определить, какие из слов «attribute», «класс», «функция», «type» невозможно записать в байтовом типе.)
[comment]: <> (4. Преобразовать слова «разработка», «администрирование», «protocol», «standard» из строкового представления в байтовое и выполнить обратное преобразование &#40;используя методы encode и decode&#41;.)
[comment]: <> (5. Выполнить пинг веб-ресурсов yandex.ru, youtube.com и преобразовать результаты из байтовового в строковый тип на кириллице.)
[comment]: <> (6. Создать текстовый файл test_file.txt, заполнить его тремя строками: «сетевое программирование», «сокет», «декоратор». Проверить кодировку файла по умолчанию. Принудительно открыть файл в формате Unicode и вывести его содержимое.)
